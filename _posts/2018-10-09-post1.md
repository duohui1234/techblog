---
layout: post
title:  "HTTPS와 SSL인증서"
author: "DahyeJung"
---

<br/>

이고잉님의 'HTTPS와 SSL 인증서' 도큐먼트를 보고 큰 깨달음을 얻어 나름대로 정리해 본 글이다. 이 포스팅을 시작으로 웹의 보안적인 측면에 대해 더 깊게 공부해보고 aws로 배포한 두 개의 프로젝트에 SSL 인증서를 적용해 보안을 강화할 예정이다.  

>  ['HTTPS와 SSL 인증서' by 생활코딩](https://opentutorials.org/course/228/4894)

<br/><br/>

# SSL의 메커니즘 

- SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서다. 

  <br/>

- 대칭키

  - 동일한 키로 암호와와 복화화를 둘다 할 수 있는 방식의 암호화 기법이다.

  - 그렇기 때문에 이 대칭키가 노출되면 암호의 내용이 복화화 된다는 한계가 있다.

    <br/>

- 공개키

  - 공개키는 A키로 암호화하면 B키로 복호화 할 수 있고, B키로 암호화하면 A키로 복호화 할 수 있는 암호화 기법이다.

  - 두개의 키 중 하나는 비공개키, 나머지 하나는 공개키로 지정한다. 

  - 이 공개키와 비공개키는 2가지 방식으로 활용될 수 있다.

    1.  비공개키는 내가 가지고 있고 공개키는 타인에게 제공한다. 공개키를 가지고 있는 타인은 공개키를 이용해 정보를 암호화한 후 비공개키를 가지고 있는 나에게 전송한다. 나는 비공개키를 이용해서 정보를 복호화 할 수 있다. 이 과정에서 공개키가 유출되더라도 비공개키를 모르면 암호를 복호화할 수 없기 때문에 안전.

    2. 비공개키의 소유자는 비공개키를 이용해서 정보를 암호화 하고, 암호화된 정보와 공개키를 전송한다. 이 정보와 공개키를 받은 사람은 공개키를 이용하여 암호화 된 정보를 복호화한다. 이 과정에서 공개키가 유출된다면? 암호화된 정보가 복호화 될 위험이 있다. 그럼에도 불구하고 이 방식을 사용하는 이유는 이 방식은 데이터를 보호하는 것이 목적이 아니기 때문이다. 암호화된 정보를 공개키로 복호화할 수 있다는 것은, 그 정보를 제공한 사람이 공개키와 쌍을 이루고 있는 비밀키로 정보를 암호화했다는 것을 의미하고, 이것으로 그 사람의 신원을 보장할 수 있게 된다.

       <br/>

- SSL 인증서의 역할

  - 클라이언트가 접속한 서버가 신뢰 할 수 있는 서버임을 보장한다.

     (이런 역할을 하는 기업들을 CA라고 부른다.  **각각의 브라우저마다 CA를 선정하고 그 리스트를 이미 가지고 있다** )

  - SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.

    <br/>

- SSL 인증서의 내용

  - 서비스의 정보 (인증서를 발급한 CA, 서비스의 도메인 등등)
  - 서버 측 공개키 (공개키의 내용, 공개키의 암호화 방법) 

  > 웹 브라우저가 SSL 프로토콜을 이용해서 서비스에 접속하면, 내부적으로 서버에서 그 서비스의 인증서를 클라이언트에게 전송해준다. 이 인증서는 CA에 의뢰해서 구입하는 것이다. 서버는 비밀키를 가지고 있고 비밀키와 쌍을 이루는 공개키와 서비스의 정보를 CA에 전송하면 심의를 거쳐 인증서를 제공해준다. 

<br/>

- 브라우저는 CA를 알고있다

  - 인증기관에 대한 정보를 브라우저는 이미 알고 있다. 

  > 웹 브라우저는 서버가 제공한 인증서를 보고 자신이 가지고 있는 CA리스트에 있는지 확인한다. 확인 결과 서버에서 전송한 인증서의 인증 기관이 자신이 가지고 있는 리스트에 포함되어 있다면, 브라우저는 그 기관의 공개키 역시 가지고 있기 때문에 공개키를 이용해 인증서를 복호화 한다. (*위에서 말한 2번의 방식)
  >
  > 인증서는 인증기관의 비밀키로 암호화된 것이기 때문에, 브라우저가 가지고 있는 CA의 공개키로 복호화된다는 것은, 그 기관을 신뢰할 수 있다는 것을 의미한다. 

<br/>

- SSL의 동작방법

  - 공개키와 대칭키를 혼합하여 사용한다 

  > 공개키 방식은 암호화와 복호화 과정에서 많은 컴퓨팅 파워를 쓰기 때문에, 공개키와 대칭키를 혼합하여 사용한다. 
  >
  > 실제 데이터는 대칭키로 암호화한다. 이 경우 서버와 클라이언트에서 대칭키를 공유하고 있어야 함. 이 대칭키를 암호화하는 방식으로는 공개키 방식을 사용한다. 

  - 통신의 3단계 `악수 -> 전송 -> 세션종료`

    <br/>

  #### 1. 악수(handshake)

  클라이언트와 서버가 서로 탐색하고 파악하는 과정. 

  - 서버 측에서 생성한 랜덤데이터를 주고 받는다.

  - 서버와 클라이언트는 서로 어떠한 암호화 기법을 처리할 수 있는지 공유하고, 어떤 암호화 기법을 쓸지 협상한다. 

  - **서버는 인증서를 클라이언트에 전송한다**.

     (인증서의 인증기관이 브라우저에 내장되어있는 리스트에 있는지 확인 -> 브라우저가 가진 공개키로 복호화 시도)

  - 클라이언트는 복호화된 인증서 안에 포함되어 있는 공개키를 획득. 서버는 비밀키를 가지고 있다.

  - 클라이언트는 앞서 서버와 주고받은 랜덤 데이터와 클라이언트가 생성한 랜덤 데이터를 조합하여 pre master key 생성한다. 그렇다면 이 키를 어떻게 하면 안전하게 서버로 전송할 수 있을 까. 이 때 인증서 안에 있던 서버의 공개키를 사용하여 암호화한 pre master key를 전송한다. 서버는 비공개키를 가지고 이 데이터를 복호화한다. 이로서 **서버와 클라이언트가 모두 pre master secret 값을 공유할 수 있게 되었다**.  

  > 그리고 서버와 클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 master secret 값으로 만든다. master secret는 session key를 생성하는데 이 session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화 한 후에 주고 받는다.

  <br/>

  #### 2. 세션

  서버와 클라이언트가 실제로 데이터를 주고 받는 단계

  <br/>

  #### 3. 세션종료 

  데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다. 이 때 통신에서 사용한 대칭키인 세션키를 폐기한다.
